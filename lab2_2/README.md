# Парсер языка спецификации синтаксических анализаторов

## Описание языка

Язык спецификации для генератора синтаксических анализаторов состоит из следующих секций:

1. `%class` - задает имя генерируемого класса синтаксического анализатора
2. `%tokens` - список токенов (терминальных символов)
3. `%types` - сопоставление нетерминалам и терминалам их типов
4. `%methods` - сигнатуры методов для обработки правил
5. `%grammar` - правила грамматики
6. `%axiom` - начальный символ грамматики
7. `%end` - маркер конца спецификации

### Лексическая структура

- Идентификаторы: последовательность букв, цифр, символов подчеркивания и дефисов, начинающаяся с буквы
- Ключевые слова: `%class`, `%tokens`, `%types`, `%methods`, `%grammar`, `%axiom`, `%end`, `%rep`
- Разделители: `,`, `:`, `;`, `(`, `)`, `[`, `]`, `=`, `|`, `/`
- Комментарии: начинаются с символа `$` и продолжаются до конца строки

### Правила грамматики

В секции `%grammar` определяются правила вида:
```
НетерминальныйСимвол = Альтернатива1 | Альтернатива2 | ... ;
```

Каждая альтернатива состоит из последовательности терминальных и нетерминальных символов и может завершаться вызовом метода:
```
Символ1 Символ2 ... / ИмяМетода
```

Для обозначения повторения элемента используется оператор `%rep`:
```
%rep (Элемент)
```

## Абстрактное синтаксическое дерево

Абстрактное синтаксическое дерево представлено следующими классами:

- `TypeName` - тип (имя и флаг массива)
- `TypeMapping` - сопоставление имен с типами
- `ParamType` - тип параметра
- `MethodSignature` - сигнатура метода
- `RuleElement` - элемент правила (базовый класс)
  - `IdRuleElement` - идентификатор
  - `RepRuleElement` - повторение элемента
  - `ParenRuleElement` - группа альтернатив в скобках
- `RuleAlternative` - альтернатива правила
- `GrammarRule` - правило грамматики
- `Spec` - полная спецификация

## Использование

```bash
python main.py <файл_спецификации>
```

## Пример спецификации

```
%class
  SimpleImperativeLang

%tokens
  NUMBER PLUS MINUS STAR FRAC LBRAC RBRAC

%types
  Expr, Term, Factor, NUMBER: ArithmExpr;

%methods
  ArithmExpr neg_op(ArithmOp, ArithmExpr);
  ArithmExpr bin_op(ArithmExpr, ArithmExprChunk[]);

%grammar
  Expr = (Term | MINUS Term / neg_op) %rep ((PLUS | MINUS) Term / chunk)
      / bin_op;
  Term = Factor %rep ((STAR | FRAC) Factor / chunk) / bin_op;
  Factor = NUMBER | VAR / deref | LBRAC Expr RBRAC;

%axiom
  Program

%end
``` 