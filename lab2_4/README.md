# Лабораторная работа № 2.4 «Рекурсивный спуск»

Синтаксический анализатор для подмножества языка Оберон, реализованный методом рекурсивного спуска.

## Описание проекта

Данный проект представляет собой синтаксический анализатор для подмножества языка Оберон. Анализатор построен методом рекурсивного спуска и генерирует абстрактное синтаксическое дерево (AST) для входной программы.

### Компоненты проекта:

1. **AST.hs** - Определение типов данных для абстрактного синтаксического дерева
2. **Lexer.hs** - Лексический анализатор для языка Оберон
3. **Parser.hs** - Синтаксический анализатор, реализованный методом рекурсивного спуска
4. **Main.hs** - Основной файл программы

## Сборка и запуск

### Требования

- GHC (Glasgow Haskell Compiler)
- Cabal (система сборки для Haskell)

### Сборка проекта

```bash
cd lab2_4
cabal build
```

### Запуск программы

```bash
cabal run oberon-parser test.oberon
```

### Режим отладки

Для вывода токенов и абстрактного синтаксического дерева можно использовать режим отладки:

```bash
cabal run oberon-parser -- --debug test.oberon
```

## Грамматика языка

Подмножество языка Оберон поддерживает следующие конструкции:

- Объявления типов и переменных
- Записи (возможно с наследованием)
- Указатели и операции с ними
- Условные операторы (IF-THEN-ELSE)
- Циклы (WHILE-DO)
- Операторы присваивания
- Выражения с поддержкой приоритета операций

Полная грамматика определена в файле `lab.md`.

## Пример программы

```
TYPE
  Point = RECORD
    x, y : REAL;
  END;
  Shape = RECORD
    center : Point;
    color : INTEGER;
    next : POINTER TO Shape;
  END;

VAR
  p1 : Point;
BEGIN
  p1.x := 10;
  p1.y := 3.5;
END.
```

## Отчет

Данный проект реализует синтаксический анализатор методом рекурсивного спуска. 
Рекурсивный спуск – это метод синтаксического анализа, при котором для каждого нетерминала грамматики создается функция, которая распознает соответствующую конструкцию языка.

В проекте используется функциональный подход к построению анализатора, что делает код более чистым и элегантным. Использование монады Either для обработки ошибок позволяет элегантно передавать ошибки разбора через цепочку вызовов функций. 