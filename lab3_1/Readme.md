
# Лабораторная работа № 3.1: Самоприменимый генератор компиляторов на основе предсказывающего анализа

## 1. Цель работы
Целью данной работы является разработка простейшего генератора компиляторов, который по описанию грамматики рабочего языка строит таблицы предсказывающего LL(1)-анализа. Ключевым аспектом является самоприменимость генератора, то есть способность сгенерировать таблицу разбора для языка описания грамматик (GDL) с использованием таблицы, сгенерированной им самим.

Работа основана на результатах Лабораторной работы 2.3, где был разработан предсказывающий парсер для GDL с жестко закодированной логикой разбора.

## 2. Структура проекта

Проект состоит из нескольких модулей:

*   `common.py`: Общие определения (токены, узлы AST, классы исключений) и утилиты (генерация DOT-представления дерева).
*   `gdl_lexer.py`: Лексический анализатор для языка описания грамматик (GDL). Выделяет токены: `LBRACK`, `RBRACK`, `LPAREN`, `RPAREN`, `OP`, `IDENT`, `KW_AXIOM`, `KW_N`, `EOF`. Пропускает комментарии (`%`) и пробельные символы.
*   `gdl_parser_hardcoded.py`: Предсказывающий синтаксический анализатор для GDL. Реализован с жестко закодированной логикой выбора продукций (без явной таблицы). Строит абстрактное синтаксическое дерево (AST) GDL-файла.
*   `grammar_analyzer.py`: Модуль, содержащий логику анализа грамматики, извлеченной из AST GDL. Вычисляет множества FIRST и FOLLOW для данной грамматики и строит по ним LL(1) таблицу разбора. Также включает проверки на соответствие грамматики требованиям (наличие аксиомы, отсутствие LL(1) конфликтов и т.д.).
*   `compiler_generator.py`: Основной скрипт **Этапа 1**. Читает GDL-файл, использует `gdl_lexer` и `gdl_parser_hardcoded` для его разбора, затем передает полученное AST в `grammar_analyzer` для построения LL(1) таблицы и сохраняет ее в виде Python-кода.
*   `generic_ll1_parser.py`: Универсальный предсказывающий синтаксический анализатор, который работает на основе переданной ему LL(1) таблицы разбора. Может парсить любой язык, для которого предоставлена таблица и соответствующий лексер.
*   `calculator_lexer.py`: Лексический анализатор для простого языка арифметических выражений (калькулятора). Выделяет токены: `+`, `*`, `(`, `)`, `n`, `EOF`.
*   `calculator_evaluator.py`: (Опционально) Модуль для обхода дерева разбора арифметического выражения и его вычисления.
*   `calculator.py`: Основной скрипт **Этапа 2**. Читает LL(1) таблицу разбора (сгенерированную `compiler_generator.py`), читает файл с арифметическим выражением, использует `calculator_lexer` и `generic_ll1_parser` для разбора выражения и (опционально) вычисляет результат.
*   `bootstrapper.py`: Скрипт для демонстрации **Раскрутки**. Использует `gdl_lexer` и `generic_ll1_parser` (который работает по таблице для GDL, сгенерированной ранее) для разбора GDL-файла пользовательской грамматики, затем передает AST в `grammar_analyzer` для построения LL(1) таблицы для этой грамматики.

**Файлы грамматик:**

*   `calculator_grammar.gdl`: Описание грамматики простого калькулятора на языке GDL.
*   `gdl_grammar_for_bootstrap.gdl`: Описание грамматики самого языка GDL на языке GDL.

**Тестовый ввод:**

*   `expression.txt`: Файл с примером арифметического выражения.

## 3. Язык описания грамматик (GDL)

Синтаксис GDL описан в отчете по ЛР 2.3. Кратко:
- Правила заключены в `[...]`.
- Аксиома: `[axiom [ИМЯ_АКСИОМЫ]]`.
- Определение правил для нетерминала: `[ИМЯ_НЕТЕРМИНАЛА [Правило1] [Правило2] ...]`.
- Правая часть правила: `[Символ1 Символ2 ...]`. Пустая правая часть: `[]` (обозначает ε).
- Символы в правой части: `IDENT` (нетерминалы или терминалы), `OP`, `LPAREN`, `RPAREN`, `KW_N` ('n').
- Комментарии: `%` до конца строки.

## 4. Ошибки грамматики

Генератор компиляторов способен обнаруживать следующие ошибки в описании грамматики:

*   Не указана аксиома грамматики.
*   Наличие нетерминального символа, который определен (был LHS или аксиомой), но для него не присутствуют правила.
*   Использование символа в правой части правила, который не определен как нетерминал и не является одним из известных терминалов (OP, LPAREN, RPAREN, KW_N, EOF).
*   Грамматика не относится к классу LL(1) (обнаружение FIRST/FIRST и FIRST/FOLLOW конфликтов при построении таблицы).

Все ошибки сопровождаются указанием примерных координат в исходном GDL-файле.

## 5. Запуск и тестирование

Предполагается, что все файлы проекта находятся в одной директории и установлен Python 3.x. Для визуализации DOT-файлов требуется установленный Graphviz (`dot` в PATH).

**5.1. Шаг 1: Генерация таблицы для грамматики калькулятора (Используя жестко закодированный парсер GDL)**

```bash
# Создание таблицы разбора для грамматики калькулятора
python compiler_generator.py calculator_grammar.gdl -o calc_table.py --dot_gdl_ast calc_gdl_ast.dot --show_first_follow

# Просмотр AST GDL файла (опционально, требует Graphviz)
dot -Tpng calc_gdl_ast.dot -o calc_gdl_ast.png
```
*   `compiler_generator.py`: Использует свой встроенный парсер GDL для разбора `calculator_grammar.gdl`.
*   Вывод: `calc_table.py` (таблица для калькулятора), `calc_gdl_ast.dot` (AST `calculator_grammar.gdl`).

**5.2. Шаг 2: Тестирование калькулятора (Используя сгенерированную таблицу)**

```bash
# Создание тестового файла с выражением (если его нет)
# expression.txt
# n + n * ( n + n )

# Разбор и вычисление выражения с помощью сгенерированной таблицы
python calculator.py calc_table.py expression.txt -o calc_expr_parsetree.dot

# Просмотр дерева разбора выражения (опционально, требует Graphviz)
dot -Tpng calc_expr_parsetree.dot -o calc_expr_parsetree.png
```
*   `calculator.py`: Загружает `calc_table.py` и использует `generic_ll1_parser` для разбора `expression.txt`.

**5.3. Шаг 3: Генерация таблицы для грамматики самого GDL (Подготовка к раскрутке)**

Эта команда использует `compiler_generator.py` для обработки `gdl_grammar_for_bootstrap.gdl` и создания таблицы разбора для языка GDL (`gdl_table.py`).

```bash
# Создание таблицы разбора для грамматики GDL
python compiler_generator.py gdl_grammar_for_bootstrap.gdl -o gdl_table.py --dot_gdl_ast gdl_bootstrap_ast.dot --show_first_follow

# Просмотр AST GDL для самой GDL грамматики (опционально, требует Graphviz)
dot -Tpng gdl_bootstrap_ast.dot -o gdl_bootstrap_ast.png
```
*   Вывод: `gdl_table.py` (таблица для GDL), `gdl_bootstrap_ast.dot` (AST `gdl_grammar_for_bootstrap.gdl`).

**5.4. Шаг 4: Раскрутка - Генерация таблицы калькулятора с помощью Bootstrapper**

Теперь `bootstrapper.py` (использующий `generic_ll1_parser` и таблицу `gdl_table.py`) парсит `calculator_grammar.gdl` и генерирует таблицу разбора для калькулятора.

```bash
# Генерация таблицы калькулятора с использованием bootstrapper'а и таблицы GDL
python bootstrapper.py gdl_table.py calculator_grammar.gdl -o calc_table_bootstrapped.py --dot_user_gdl_ast calc_gdl_ast_boot.dot

# Просмотр AST calculator_grammar.gdl, построенного табличным парсером GDL (опционально)
dot -Tpng calc_gdl_ast_boot.dot -o calc_gdl_ast_boot.png
```
*   Сравните `calc_table_bootstrapped.py` с `calc_table.py` из Шага 1. Они должны быть идентичны (или логически эквивалентны), что демонстрирует корректность сгенерированной таблицы GDL и универсального парсера.

**5.5. Шаг 5 (Опционально): Полная самоприменимость**

Демонстрация генерации таблицы GDL с помощью `bootstrapper.py`, который сам использует таблицу GDL.

```bash
# Генерация таблицы GDL с использованием bootstrapper'а и таблицы GDL же
python bootstrapper.py gdl_table.py gdl_grammar_for_bootstrap.gdl -o gdl_table_fully_bootstrapped.py
```
*   Сравните `gdl_table_fully_bootstrapped.py` с `gdl_table.py` из Шага 3. Они также должны быть идентичны.

## 6. Зависимости

*   Python 3.x
*   Graphviz (для визуализации `.dot` файлов, опционально)

