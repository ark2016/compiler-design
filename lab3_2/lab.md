## Язык L2 — краткое описание + формальная грамматика (EBNF)

### 1  Лексика&#x20;

| Класс лексем                | Вид записи                                                                                                                           | Примечание                                          |                                            |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------- | ------------------------------------------ |
| **Идентификатор**           | `{` последовательность букв, цифр, «\_», пробелов `}`                                                                                | Юникод-буквы любых алфавитов                        |                                            |
| **Ключевые слова**          | `bool char int void return loop while then else null true false`                                                                     | `null` — ссылочная константа; `true/false` — булевы |                                            |
| **Литералы**                | целые (неотрицательные, опционально `$base` 2–36),<br>символьные `$"c"` или `$"%BEL%"`,<br>строковые `"..."`,<br>булевы `true/false` | См. раздел 2.4 спецификации                         |                                            |
| **Комментарии**             | строковый `## … ⏎`, многострочный `#( … )#`                                                                                          | игнорируются сканером                               |                                            |
| **Разделители и операторы** | \`\~ ; , \[ ] ( ) ^ \* / % - + = := <- ! &                                                                                           | @ == != < > <= >=\`                                 | используют правило «самой длинной лексемы» |

Не­видимые пробельные символы (пробел, TAB, EOL) между лексемами игнорируются, но должны отделять смежные идентификаторы/ключевые слова и константы.

---

### 2  Синтаксис (EBNF)


```
program         := func_def+

func_def        := func_header '=' block '.'
func_header     := type_or_void ident ('<-' formal_params)?
formal_params   := param (',' param)*
param           := type ident

type_or_void    := type | 'void'
type            := prim_type ('[' ']')*
prim_type       := 'int' | 'char' | 'bool'

block           := stmt_list
stmt_list       := statement (';' statement)*

statement       := decl_stmt
                 | assign_stmt
                 | call_stmt
                 | if_stmt
                 | while_stmt
                 | for_stmt
                 | do_while_stmt
                 | return_stmt

# ─── объявления ────────────────────────────────────────────────────
decl_stmt       := type decl_item (',' decl_item)*
decl_item       := ident (':=' expr)?

# ─── присваивание ──────────────────────────────────────────────────
assign_stmt     := lvalue ':=' expr
lvalue          := ident ('[' expr ']')*

# ─── вызов-как-оператор ────────────────────────────────────────────
call_stmt       := ident '<-' arg_list
arg_list        := (expr (',' expr)*)?

# ─── выбор, циклы, возврат ─────────────────────────────────────────
if_stmt         := expr 'then' block ('else' block)? '.'
while_stmt      := expr 'loop' block '.'
for_stmt        := expr '~' expr 'loop' ident block '.'
do_while_stmt   := 'loop' block 'while' expr '.'
return_stmt     := 'return' expr?

# ================================================================
#                В Ы Р А Ж Е Н И Я  (уровни 1 – 11)
# ================================================================
expr            := logic_or                                   # lvl 11

logic_or        := logic_xor ('|'  logic_xor)*                # lvl 10
logic_xor       := logic_and ('@'  logic_and)*                # lvl 9
logic_and       := equality  ('&'  equality)*                 # lvl 8
equality        := relation  (('==' | '!=') relation)*        # lvl 7
relation        := call      (('<' | '>' | '<=' | '>=') call)*# lvl 6

call            := add_sub ('<-' arg_list)*                   # lvl 6
                # левый операнд может быть любым выражением с lvl ≤ 5

add_sub         := mul ('+' mul | '-' mul)*                   # lvl 5
mul             := power ('*' power | '/' power | '%' power)* # lvl 4
power           := unary ('^' unary)*                         # lvl 2 (right-assoc)

unary           := ('-' | '!') unary                          # lvl 3
                 | primary

# ---------- уровень 1: alloc + постфикс индексации -------------
primary         := alloc
                 | atom ('[' expr ']')*                       # indexing shares lvl 1

alloc           := type expr                                  # highest precedence
                 | atom ('[' expr ']')*                       # позволяем char[n][m]

atom            := const                                     # идентификатор, константа
                 | ident
                 | '(' expr ')'

const           := INT_CONST | CHAR_CONST | STRING_CONST
                 | 'true' | 'false' | 'null'


```



#### Предшествования/ассоциативность операторов

Бинарные операторы перечислены в таблице 2 спецификации; в грамматике они отражены каскадом нетерминалов, обеспечивающим тот же приоритет и левую/правую ассоциативность (символ `←` в табл. 2 означает **right-to-left**) .

---

### 3  Семантические оговорки (для полноты)

* Левый операнд присваивания `<lvalue>` обязан обозначать «ячейку»: локальную переменную, параметр или элемент массива .
* В `call-stmt` вызываемая функция должна иметь результат `void`; в `call-expr` — любой непустой тип.
* В `alloc` выражение‐размер имеет тип `int`; результат — ссылка на массив требуемого типа .
* Типы фактических параметров при вызове функции должны совпадать с формальными .
* `return` без выражения допускается только в функциях вида `void`.

---

### 4  Минимальный пример (корректная программа на L2)

```L2
int {Main} <- char[ ][ ] {args} =
  int {i} := 0;
  int {sum} := 0;
  {len}               := {Length} <- {args};
  {i} ~ {len} - 1 loop {i}
    {sum} := {sum} + 1
  .
  return {sum}.
```


