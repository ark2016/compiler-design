

### 1. Абстрактный синтаксис языка



*   **Программа:** Состоит из опционального раздела объявлений типов, опционального раздела объявлений переменных и обязательного блока операторов.
*   **Объявление типа:** Связывает имя (идентификатор) с определением типа.
*   **Определение типа:** Может быть базовым типом (REAL, INTEGER), указателем на другой тип, или записью.
*   **Определение записи:** Состоит из опционального имени родительского типа (для наследования) и списка объявлений полей.
*   **Объявление полей:** Список имен (идентификаторов) полей одного типа.
*   **Объявление переменной:** Список имен (идентификаторов) переменных определенного типа.
*   **Последовательность операторов:** Упорядоченный список операторов, выполняемых последовательно.
*   **Оператор:** Является одним из:
    *   **Присваивание:** Присвоить значение выражения некоторому **Пути доступа** (L-значению).
    *   **Условный оператор (IF):** Вычислить условие (выражение); если истинно, выполнить один блок операторов; опционально, если ложно, выполнить другой блок.
    *   **Цикл (WHILE):** Вычислить условие (выражение); если истинно, выполнить блок операторов, затем повторить; если ложно, выйти из цикла.
    *   **Вызов NEW:** Выделить память для объекта, на который указывает переменная-**Путь доступа** (указатель).
*   **Выражение:** Представляет вычисляемое значение. Имеет структуру, определяемую приоритетом и ассоциативностью операций:
    *   **Отношение/Сравнение:** Два простых выражения, связанные оператором сравнения (=, #, <, <=, >, >=). Неассоциативно.
    *   **Простое выражение:** Опциональный унарный знак (+/-), за которым следуют члены (Term), связанные аддитивными операторами (+, -, OR). Левоассоциативны.
    *   **Терм:** Фактор, за которым следуют факторы, связанные мультипликативными операторами (*, /, DIV, MOD, AND). Левоассоциативны.
    *   **Фактор:** Может быть:
        *   Значением **Пути доступа** (R-значением).
        *   Литералом (целым или вещественным).
        *   Выражением в скобках.
        *   Унарным оператором NOT, примененным к другому фактору.
*   **Путь доступа (Access Path):** Представляет место в памяти (переменную, поле записи, объект по указателю), к которому можно обратиться. Состоит из базового идентификатора (имя переменной) и последовательности **Шагов доступа**.
*   **Шаг доступа (Access Step):** Применяется к **Пути доступа** для получения нового **Пути доступа**:
    *   **Доступ к полю:** `. ИдентификаторПоля`.
    *   **Разыменование указателя:** `^`.

---

### 2. Лексическая структура языка



*   **Пробельные символы:** Пробелы, табуляции, переводы строки. **Игнорируются**.
*   **Комментарии:** Последовательность `(*` ... `*)`. **Игнорируются**. (Пример не демонстрирует вложенность, но в полном Обероне она есть. Для данного подмножества будем считать, что вложенность не поддерживается простой регуляркой).
*   **Ключевые слова:** Точные, **чувствительные к регистру** последовательности заглавных букв. Имеют приоритет над идентификаторами.
    `TYPE`, `RECORD`, `END`, `POINTER`, `TO`, `VAR`, `BEGIN`, `WHILE`, `DO`, `IF`, `THEN`, `ELSE`, `NEW`, `REAL`, `INTEGER`, `NOT`, `AND`, `DIV`, `MOD`, `OR`.
*   **Идентификаторы:** Последовательность букв (заглавных или строчных), цифр и символов подчеркивания, начинающаяся с буквы. **Чувствительны к регистру**. Не должны совпадать с ключевыми словами.
    Пример: `p1`, `x`, `Shape`, `center`, `radius`, `height`.
*   **Литералы:**
    *   **Целочисленные:** Последовательность цифр. Пример: `10`, `100500`, `77777`.
    *   **Вещественные:** Последовательность цифр, точка, последовательность цифр. Пример: `3.5`, `5.2`, `2.5`, `4.5`, `5.4`, `1.5`, `2.5`.
*   **Операторы и пунктуация:**
    *   Составные: `:=`, `<=`, `>=`
    *   Одиночные: `+`, `-`, `*`, `/`, `=`, `#`, `<`, `>`, `.`, `,`, `;`, `:`, `(`, `)`, `^`.
*   **Конец файла (EOF):** Специальный токен, генерируемый лексером после обработки всего входного текста.

---

### 3. Синтаксис языка в LL(1) РБНФ

```ebnf
Program = ( "TYPE" ( TypeDeclaration ";" )* )?
          ( "VAR" ( VarDeclaration ";" )* )?
          "BEGIN" StatementSequence "END" "." EOF .

TypeDeclaration = Ident "=" Type .

VarDeclaration = IdentList ":" Type .

IdentList = Ident ( "," Ident )* .

Type = "REAL"
     | "INTEGER"
     | "POINTER" "TO" Type
     | "RECORD" ( "(" Ident ")" )? ( FieldDeclaration ";" )* "END" .

FieldDeclaration = IdentList ":" Type .

StatementSequence = Statement ( ";" Statement )* .

Statement = Assignment
          | IfStatement
          | WhileStatement
          | NewStatement
          .

Assignment = Designator ":=" Expression . 

IfStatement = "IF" Expression "THEN" StatementSequence ( "ELSE" StatementSequence )? "END" .

WhileStatement = "WHILE" Expression "DO" StatementSequence "END" .

NewStatement = "NEW" "(" Designator ")" . 

Expression = SimpleExpression ( Relation SimpleExpression )? .

Relation = "=" | "#" | "<" | "<=" | ">" | ">=" .

SimpleExpression = ( "+" | "-" )? Term ( AddOp Term )* .

AddOp = "+" | "-" | "OR" .

Term = Factor ( MulOp Factor )* .

MulOp = "*" | "/" | "DIV" | "MOD" | "AND" .

Factor = DesignatorExpr
       | IntLiteral
       | RealLiteral
       | "(" Expression ")"
       | "NOT" Factor .

DesignatorExpr = Designator . 

Designator = Ident ( Selector )* . 

Selector = "." Ident
         | "^" . 

Ident = identifier_token .
IntLiteral = integer_literal_token .
RealLiteral = real_literal_token .
```

---
